<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
    </head>
    <body>
        <script src="https://s3.ap-northeast-2.amazonaws.com/kiwiprojcdn/libs/three.js"></script>
        <!-- <script src="http://kiwiprojcdn.herokuapp.com/htdocs/js/rovercamera.js"></script>-->

        <script>
            // issues that need to be fixed start with !

            class RoverCamera extends THREE.PerspectiveCamera {
                constructor(fov, aspratio, nearpln, farpln, lat, long) {
                    super(fov, aspratio, nearpln, farpln);

                    this.lat = lat;
                    this.long = long;
                }

                generateGeometry(callback) {
                    var latStr = (this.lat > 0 ? "N" : "S") + Math.floor(this.lat).toString(); // ex: N37
                    var longStr = (this.long > 0 ? "E" : "W") + Math.floor(this.long).toString(); // ex: E127
                    var latlongStr = latStr + longStr; // ex: N37E127

                    var latRem = this.lat - Math.floor(this.lat); // to assess the rover's position on the datamap
                    var longRem = this.long - Math.floor(this.long); // "
                    var metresPerLong = 111319.5; // to convert lat/long pair to metric coordinates
                    var metresPerLat = 111132.9; // ! needs to be calculated accurately according to lat/long

                    //this.position.set(-1 * (longRem * metresPerLong) + metresPerLong / 2, -1 * (latRem * metresPerLat) + metresPerLat / 2, 0);
                    this.position.set(0,0,10);

                    this.groundGeometry = new THREE.PlaneBufferGeometry(metresPerLong, metresPerLat, 1200, 1200); // the geometry to map the data into

                    var datamapReq = new XMLHttpRequest(); // to import .hgt file from server
                    datamapReq.open("GET", "https://s3.ap-northeast-2.amazonaws.com/kiwiprojcdn/elvdata/" + latlongStr + ".hgt");
                    datamapReq.responseType = "arraybuffer";
                    console.log('setup done!');

                    datamapReq.onload = function(event) {
                        var dataBuffer = datamapReq.response;
                        if(dataBuffer) {
                            var dataArray = new Uint8Array(dataBuffer);
                            
                            for(var idx=0; idx < dataArray.byteLength/2; idx++) { // read data bytewise
                                var remX = 1201 - idx % 1201; // since the vertices array is 'flipped' along the x axis, the data needs to be inverted in order to map correctly
                                var Y = Math.floor(idx / 1201);

                                // x: + => west, - => east
                                // y: + => north, - => south

                                var elevation = 256 * dataArray[idx * 2] + dataArray[idx * 2 + 1];
                                this.groundGeometry.vertices[Y * 1201 + remX].z = elevation;
                            }

                            this.groundGeometry.verticesNeedUpdate = true;

                            //this.position.z = dataArray[Math.floor(latRem * 1201) * 1201 + Math.floor(longRem * 1201)] + 1.7; // access the according elevation; ! needs to be changed to support S, W
                        }

                        callback(this.groundGeometry);
                    }

                    datamapReq.send(null);
                }
            }
        </script>

        <script>
            // 1 : 1 metre

            var camera, scene, renderer;
            var geometry, material, ground;

            var theta = 0;

            init();
            //animate();

            function init() {
                scene = new THREE.Scene();
                camera = new RoverCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000, 37.5886567, 126.9871959);
                //camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
                camera.position.z = 1000;

                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                camera.generateGeometry(callback);
                //geometry = new THREE.PlaneBufferGeometry(100,100,1,1);
                //geometry = new THREE.BoxGeometry(1,1,1);

                var callback = function(gmt) {
                    geometry = gmt;
                    material = new THREE.MeshDepthMaterial();
                    ground = new THREE.Mesh(geometry, material);

                    scene.add(ground);
                    renderer.render(scene, camera);
                }

                //camera.up = new THREE.Vector3(0,0,1);
                //camera.lookAt(new THREE.Vector3(Math.cos(theta),Math.sin(theta),0));

                
            }

            /*function animate() {
                requestAnimationFrame(animate);

                theta += 0.01;
                camera.lookAt(new THREE.Vector3(Math.cos(theta),Math.sin(theta),0));

                renderer.render(scene, camera);
            }*/
        </script>
    </body>
</html>