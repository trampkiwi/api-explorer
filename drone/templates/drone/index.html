<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
    </head>
    <body>
        <script src="https://s3.ap-northeast-2.amazonaws.com/kiwiprojcdn/libs/three.js"></script>
        <!-- <script src="http://kiwiprojcdn.herokuapp.com/htdocs/js/rovercamera.js"></script>-->

        <script>
            // ---- define some functions for later use ----
            Math.degrees = function(radian) {
                return radian / (2*Math.PI) * 360;
            }

            Math.radians = function(degrees) {
                return degrees / 360 * (2*Math.PI);
            }

            // ---- define GroundGeometry class ----
            // ~ disclaimer on the coordinate system
            // ~ 1 metre corresponds to 1 'three.js coordinate system length'
            // ~ x axis: - => west, + => east
            // ~ y axis: - => north, + => south
            // ~ z axis: - => up, + => down
            class GroundGeometry extends THREE.PlaneBufferGeometry {
                constructor(latIdx, longIdx) { // both are floored lat, long
                    // ---- call super ----
                    super(1, 1, 1200, 1200);

                    // ---- transform vertices to accurately depict earth's surface ----
                    // ~ the final vertices map will 'look' trapezoidal.
                    // ~ h: height
                    // ~ the earth's shape is assumed to be completely spherical,
                    // ~ and the radius is 6371km = 6371000m.
                    this.R = 6371000.0;
                    var h = 2 * Math.PI * this.R / 360;

                    var vertices = this.attributes.position.array;

                    for(var i=0; i < vertices.length; i++) {
                        // recover x and y coordinates in datamap
                        var x = i % 1201;
                        var y = (i - x) / 1201;
                        // calculate constants
                        var latRemainder = 1 - (y / 1201);
                        var width = this.longToM(1, latIdx + latRemainder);
                        var height = h;
                        // map the vertex
                        vertices[i].x *= width;
                        vertices[i].y *= height;
                    }
                    
                    // ---- run xhr ----
                    // construct height datamap request url string
                    var reqStrLat = (latIdx > 0 ? "N" : "S") + latIdx.toString();
                    var reqStrLong = (longIdx > 0 ? "E" : "W") + longIdx.toString();
                    var reqStr = "https://s3.ap-northeast-2.amazonaws.com/kiwiprojcdn/elvdata/" + reqStrLat + reqStrLong + ".hgt";
                    // make xhr
                    var req = new XMLHttpRequest();
                    req.open("GET", reqStr);
                    req.responseType = "arraybuffer";
                    req.onload = importElevationData.bind(this);
                    req.send(null);

                    // ---- generate ground geometry ----
                    var importElevationData = function() {
                        var buffer = req.response;

                        if(buffer) {
                            var dataArr = new Uint8Array(buffer);

                            for(var i = 0; i < dataArr.byteLength/2; i++) { // read elevation data bytewise
                                var elevation = 256*dataArr[i] + dataArr[i+1]; // retrieve height data from byte array
                                vertices[i].z = -elevation; // since -z => up
                            }

                            this.attributes.position.needsUpdate = true;

                            console.log("Successfully retrieved data!");
                        } else {
                            console.log("There was a faliure while reading height data map. (index.html: line 134)");
                        }
                    }
                }

                longToM(longDeg, atLat) { // convert degree-length longDeg to m at latitude atLat
                    var r = this.R * Math.cos(Math.radians(Math.abs(atLat))); // radius of cross-section circle
                    var c = 2 * Math.PI * r; // circumference of the cross-section
                    var l = c / 360 * longDeg * 1000; // calculated m
                    return l;
                }
            }
        </script>

        <script>
            // 1 : 1 metre

            var camera, scene, renderer;
            var geometry, material, ground;

            var theta = 0;

            init();
            //animate();

            function init() {
                scene = new THREE.Scene();
                //camera = new RoverCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000, 37.5886567, 126.9871959);
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
                camera.position.z = 100;

                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                //camera.generateGeometry(callback);
                //geometry = new THREE.PlaneBufferGeometry(100,100,1,1);
                //geometry = new THREE.BoxGeometry(1,1,1);

                /*var callback = function(gmt) {
                    geometry = gmt;
                    material = new THREE.MeshDepthMaterial();
                    ground = new THREE.Mesh(geometry, material);

                    scene.add(ground);
                    renderer.render(scene, camera);
                }*/

                //camera.up = new THREE.Vector3(0,0,1);
                //camera.lookAt(new THREE.Vector3(Math.cos(theta),Math.sin(theta),0));

                geometry = new GroundGeometry(37, 126);
                material = new THREE.MeshBasicMaterial({color: 0xffffff});
                ground = new THREE.Mesh(geometry, material);

                scene.add(ground);
                renderer.render(scene, camera);
            }

            /*function animate() {
                requestAnimationFrame(animate);

                theta += 0.01;
                camera.lookAt(new THREE.Vector3(Math.cos(theta),Math.sin(theta),0));

                renderer.render(scene, camera);
            }*/
        </script>
    </body>
</html>